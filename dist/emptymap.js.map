{
  "version": 3,
  "sources": [
    "node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "emptymap.js",
    "node_modules/transformatrix/index.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var Matrix = require('transformatrix');\n\nvar em = function(viewportSize,options) {\n  if(!viewportSize) return;\n  this.vpSize = viewportSize; \n  this.opt = options || {};\n  this.projExt = this.opt.projExtent || {\n    left: -20037508.342789244,\n    right: 20037508.342789244,\n    bottom: -20037508.342789244,\n    top: 20037508.342789244\n  };\n  this.tSize = this.opt.tileSize || 256;\n  this.maxRes = Math.min(\n    Math.abs(this.projExt.right - this.projExt.left)/this.tSize,\n    Math.abs(this.projExt.top - this.projExt.bottom)/this.tSize);\n  this.matrix = new Matrix();\n  this.tileMatrix = new Matrix();\n  if(this.opt.view && this.opt.callback)\n    this.setVeiw(this.opt.view,this.opt.callback,this.opt.scope);\n};\n\nem.prototype.setView = function(params) {\n  var view = params.view, \n    cb = params.callback,\n    scope = params.scope || this;\n  if (typeof(cb) !== 'function') {\n    throw new TypeError('callback is not function');\n  }\n  if(view ) {\n    view.center = view.center || [0,0];\n    view.webScale = view.webScale ? view.webScale : view.zoom\n      ? Math.pow(2,view.zoom) : view.resolution\n      ? this.maxRes/view.resolution : 0,\n    view.rotation = view.rotation || 0;\n  } else {\n    cb.call(scope,new Error('view details are wrong'));\n    return;\n  }\n  this._setAt(view.center, view.webScale, view.rotation);\n  cb.call(scope, null,{\n    matrix: this.matrix.m,\n    tileMatrix: this.tileMatrix.m,\n    map:this});\n};\n\nem.prototype.applyDeltaMove = function(params) {\n  var deltaX = params.deltaX || 0,\n    deltaY = params.deltaY || 0,\n    cb = params.callback,\n    scope = params.scope || this;\n  if (typeof(cb) !== 'function') {\n    throw new TypeError('callback is not function');\n  }\n  var basePx = this.matrix.inverse().transformPoint(deltaX,deltaY);\n  var baseVPTopLeftPx = this.matrix.inverse().transformPoint(0,0);\n  this.matrix.translate(\n    basePx[0] - baseVPTopLeftPx[0], basePx[1] - baseVPTopLeftPx[1]);\n  // apply for tile matrix\n  basePx = this.tileMatrix.inverse().transformPoint(deltaX,deltaY);\n  baseVPTopLeftPx = this.tileMatrix.inverse().transformPoint(0,0);\n  this.tileMatrix.translate(\n    basePx[0] - baseVPTopLeftPx[0], basePx[1] - baseVPTopLeftPx[1]);\n  cb.call(scope, null,{\n    matrix: this.matrix.m,\n    tileMatrix: this.tileMatrix.m,\n    map:this});\n};\n\nem.prototype.applyDeltaScaleRotation = function(params) {\n  var vpPx = params.position || [this.vpSize.width/2, this.vpSize.height/2], \n    factor = params.factor || 1,\n    rot = params.rotation || 0,\n    cb = params.callback,\n    scope = params.scope || this,\n    basePx, destBasePx;\n  if (typeof(cb) !== 'function') {\n    throw new TypeError('callback is not function');\n  }\n  basePx = this.matrix.inverse().transformPoint(vpPx[0],vpPx[1]),\n  this.matrix.translate(basePx[0],basePx[1])\n    .rotate(Math.PI*rot/180)\n    .scale(factor,factor)\n    .translate(-basePx[0],-basePx[1])\n  // for tile matrix\n  basePx = this.tileMatrix.inverse().transformPoint(vpPx[0],vpPx[1]);\n  this.tileMatrix.translate(basePx[0],basePx[1])\n    .rotate(Math.PI*rot/180)\n    .scale(factor,factor)\n    .translate(-basePx[0],-basePx[1])\n  cb.call(scope, null,{\n    matrix: this.matrix.m,\n    tileMatrix: this.tileMatrix.m,\n    map:this});\n};\n\nem.prototype.resetTileMatrix = function(params) {\n  var cb = params.callback,\n    scope = params.scope || this;\n  if (typeof(cb) !== 'function') {\n    throw new TypeError('callback is not function');\n  }\n  var rot = Math.atan2(this.tileMatrix.m[1],this.tileMatrix.m[0]);\n  this.tileMatrix.reset();\n  this.tileMatrix.translate(this.vpSize.width/2,this.vpSize.height/2)\n    .rotate(rot)\n    .translate(-this.vpSize.width/2,-this.vpSize.height/2);\n  cb.call(scope, null,{\n    matrix: this.matrix.m,\n    tileMatrix: this.tileMatrix.m,\n    map:this});\n};\n\nem.prototype.getCenter = function() {\n  var ctrBasePx = this.matrix.inverse()\n    .transformPoint(this.vpSize.width/2,this.vpSize.height/2);\n  return [\n    this.projExt.left + ctrBasePx[0]*this.maxRes,\n    this.projExt.top - ctrBasePx[1] * this.maxRes ];\n}\nem.prototype.getZoom = function() {\n  return Math.log(this._getWebScale()) / Math.log(2);\n};\nem.prototype.getNearestZoom = function() {\n  return Math.round(this.getZoom());\n};\nem.prototype._getWebScale = function() {\n  var m = this.matrix.m;\n  return Math.sqrt(m[0] * m[0] + m[1] * m[1])\n};\nem.prototype.getResolution = function() {\n  return this.maxRes/this._getWebScale();\n};\nem.prototype.getRotation = function() {\n  var m = this.matrix.m;\n  return Math.atan2(m[1],m[0]) * 180/Math.PI;\n};\nem.prototype.getView = function() {\n  return {\n    center: this.getCenter(),\n    zoom: this.getZoom(),\n    resolution: this.maxRes/this._getWebScale(),\n    rotation: this.getRotation()\n  };\n};\nem.prototype.getExtent = function() {\n  var inv = this.matrix.inverse();\n  return [\n    this._basePxToLongLat(inv.transformPoint(0,0)),\n    this._basePxToLongLat(inv.transformPoint(0,this.vpSize.height)),\n    this._basePxToLongLat(inv.transformPoint(\n      this.vpSize.width, \n      this.vpSize.height)),\n    this._basePxToLongLat(inv.transformPoint(this.vpSize.width, 0))]\n};\n\nem.prototype.toLongLat = function(px) {\n  var basePx = this.matrix.inverse().transformPoint(px[0],px[1]);\n  return this._basePxToLongLat(basePx);\n};\nem.prototype.toViewportPx = function(longLat) {\n  var basePx = this._longLatToBasePx(longLat);\n  return this.matrix.transformPoint(basePx[0],basePx[1]);\n};\n\nem.prototype.getViewportBBox = function() {\n  var extent, xArray, yArray, left, right, top, bottom;\n  extent = this.getExtent();\n  xArray = extent.map(function(pt) {return pt[0];});\n  yArray = extent.map(function(pt) {return pt[1];});\n  left = Math.min.apply(this,xArray);\n  right = Math.max.apply(this,xArray);\n  bottom = Math.min.apply(this,yArray);\n  top = Math.max.apply(this,yArray);\n  return {left: left, right: right, bottom: bottom, top: top};\n};\n\nem.prototype._setAt = function(ctr, webScale, rot) {\n  var basePx = this._longLatToBasePx(ctr);\n  this.matrix.reset();\n  this.matrix.translate(basePx[0],basePx[1])\n    .rotate(Math.PI/180*rot)\n    .scale(webScale,webScale)\n    .translate(-basePx[0],-basePx[1]);\n  var baseCenter = this.matrix.inverse()\n    .transformPoint(this.vpSize.width/2,this.vpSize.height/2);\n  this.matrix.translate(baseCenter[0] - basePx[0], baseCenter[1] - basePx[1]);\n  // for tile matrix\n  this.tileMatrix.reset();\n  this.tileMatrix.translate(this.vpSize.width/2,this.vpSize.height/2)\n    .rotate(rot * Math.PI/180)\n    .translate(-this.vpSize.width/2,-this.vpSize.height/2)\n};\nem.prototype._longLatToBasePx = function(longLat) {\n  return [\n    (longLat[0] - this.projExt.left)/this.maxRes,\n    (this.projExt.top - longLat[1])/this.maxRes];\n};\nem.prototype._basePxToLongLat = function(px) {\n  return [\n    this.projExt.left + px[0]*this.maxRes,\n    this.projExt.top - px[1]*this.maxRes];\n}\n\nmodule.exports = em; \n",
    "var Matrix = function() {\n    this.reset();\n};\nMatrix.prototype.reset = function() {\n    this.m = [1, 0, 0, 1, 0, 0];\n    return this;\n};\nMatrix.prototype.multiply = function(matrix) {\n    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1],\n        m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1],\n        m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3],\n        m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];\n\n    var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4],\n        dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    this.m[4] = dx;\n    this.m[5] = dy;\n    return this;\n};\nMatrix.prototype.inverse = function() {\n    var inv = new Matrix();\n    inv.m = this.m.slice(0);\n    var d = 1 / (inv.m[0] * inv.m[3] - inv.m[1] * inv.m[2]),\n        m0 = inv.m[3] * d,\n        m1 = -inv.m[1] * d,\n        m2 = -inv.m[2] * d,\n        m3 = inv.m[0] * d,\n        m4 = d * (inv.m[2] * inv.m[5] - inv.m[3] * inv.m[4]),\n        m5 = d * (inv.m[1] * inv.m[4] - inv.m[0] * inv.m[5]);\n    inv.m[0] = m0;\n    inv.m[1] = m1;\n    inv.m[2] = m2;\n    inv.m[3] = m3;\n    inv.m[4] = m4;\n    inv.m[5] = m5;\n    return inv;\n};\nMatrix.prototype.rotate = function(rad) {\n    var c = Math.cos(rad),\n        s = Math.sin(rad),\n        m11 = this.m[0] * c + this.m[2] * s,\n        m12 = this.m[1] * c + this.m[3] * s,\n        m21 = this.m[0] * -s + this.m[2] * c,\n        m22 = this.m[1] * -s + this.m[3] * c;\n    this.m[0] = m11;\n    this.m[1] = m12;\n    this.m[2] = m21;\n    this.m[3] = m22;\n    return this;\n};\nMatrix.prototype.translate = function(x, y) {\n    this.m[4] += this.m[0] * x + this.m[2] * y;\n    this.m[5] += this.m[1] * x + this.m[3] * y;\n    return this;\n};\nMatrix.prototype.scale = function(sx, sy) {\n    this.m[0] *= sx;\n    this.m[1] *= sx;\n    this.m[2] *= sy;\n    this.m[3] *= sy;\n    return this;\n};\nMatrix.prototype.transformPoint = function(px, py) {\n    var x = px,\n        y = py;\n    px = x * this.m[0] + y * this.m[2] + this.m[4];\n    py = x * this.m[1] + y * this.m[3] + this.m[5];\n    return [px, py];\n};\nMatrix.prototype.transformVector = function(px, py) {\n    var x = px,\n        y = py;\n    px = x * this.m[0] + y * this.m[2];\n    py = x * this.m[1] + y * this.m[3];\n    return [px, py];\n};\nif(typeof module !== \"undefined\") {\n    module.exports = Matrix;\n}\nelse {\n    window.Matrix = Matrix;\n}\n"
  ]
}